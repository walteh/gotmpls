package generate

import (
	"bytes"
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestThatFieldNamesAreOrdered(t *testing.T) {
	m := map[string]Field{
		"z": {},
		"b": {},
	}

	actual := getOrderedFieldNames(m)
	expected := []string{"b", "z"}

	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("expected %s and actual %s should match in order", strings.Join(expected, ", "), strings.Join(actual, ","))
	}
}

func TestThatStructNamesAreOrdered(t *testing.T) {
	m := map[string]Struct{
		"c": {},
		"b": {},
		"a": {},
	}

	actual := getOrderedStructNames(m)
	expected := []string{"a", "b", "c"}

	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("expected %s and actual %s should match in order", strings.Join(expected, ", "), strings.Join(actual, ","))
	}
}

func TestLineAndCharacterFromOffset(t *testing.T) {
	tests := []struct {
		In                []byte
		Offset            int
		ExpectedLine      int
		ExpectedCharacter int
		ExpectedError     bool
	}{
		{
			In:                []byte("Line 1\nLine 2"),
			Offset:            6,
			ExpectedLine:      2,
			ExpectedCharacter: 1,
		},
		{
			In:                []byte("Line 1\r\nLine 2"),
			Offset:            7,
			ExpectedLine:      2,
			ExpectedCharacter: 1,
		},
		{
			In:                []byte("Line 1\nLine 2"),
			Offset:            0,
			ExpectedLine:      1,
			ExpectedCharacter: 1,
		},
		{
			In:                []byte("Line 1\nLine 2"),
			Offset:            200,
			ExpectedLine:      0,
			ExpectedCharacter: 0,
			ExpectedError:     true,
		},
		{
			In:                []byte("Line 1\nLine 2"),
			Offset:            -1,
			ExpectedLine:      0,
			ExpectedCharacter: 0,
			ExpectedError:     true,
		},
	}

	for _, test := range tests {
		actualLine, actualCharacter, err := lineAndCharacter(test.In, test.Offset)
		if err != nil && !test.ExpectedError {
			t.Errorf("Unexpected error for input %s at offset %d: %v", test.In, test.Offset, err)
			continue
		}

		if actualLine != test.ExpectedLine || actualCharacter != test.ExpectedCharacter {
			t.Errorf("For '%s' at offset %d, expected %d:%d, but got %d:%d", test.In, test.Offset, test.ExpectedLine, test.ExpectedCharacter, actualLine, actualCharacter)
		}
	}
}

func TestGenerateAnyOfOneOfAllOfOutput(t *testing.T) {
	// Since the generator tests already verify the type generation and marshaling/unmarshaling,
	// this test should focus on the output-specific concerns:
	// 1. The generated code structure
	// 2. The package name handling
	// 3. The imports
	// 4. The file organization

	schema := &Schema{}
	err := json.Unmarshal([]byte(`{
		"$schema": "http://json-schema.org/draft-04/schema#",
		"oneOf": [
			{ "type": "string" },
			{ "type": "number" }
		]
	}`), schema)
	require.NoError(t, err, "schema should parse successfully")

	g := New(schema)
	err = g.CreateTypes()
	require.NoError(t, err, "types should be generated successfully")

	// Test different package names
	testCases := []struct {
		name         string
		packageName  string
		expectInCode []string // Strings that should appear in the generated code
		skipInCode   []string // Strings that should not appear in the generated code
	}{
		{
			name:        "default_package",
			packageName: "main",
			expectInCode: []string{
				"package main",
				"import (",
				"\"encoding/json\"",
				"\"fmt\"",
				"type Root_OneOf struct",
				"func (o *Root_OneOf) UnmarshalJSON",
				"func (o *Root_OneOf) MarshalJSON",
			},
			skipInCode: []string{
				"package generate",
				"// Code generated by something else",
			},
		},
		{
			name:        "custom_package",
			packageName: "custom.path/mypackage",
			expectInCode: []string{
				"package mypackage",
				"import (",
				"\"encoding/json\"",
				"\"fmt\"",
				"type Root_OneOf struct",
			},
			skipInCode: []string{
				"package main",
				"package generate",
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var buf bytes.Buffer
			err = Output(&buf, g, tc.packageName)
			require.NoError(t, err, "should generate code successfully")

			generatedCode := buf.String()

			// Verify expected strings are present
			for _, expect := range tc.expectInCode {
				assert.Contains(t, generatedCode, expect, "generated code should contain %q", expect)
			}

			// Verify unwanted strings are not present
			for _, skip := range tc.skipInCode {
				assert.NotContains(t, generatedCode, skip, "generated code should not contain %q", skip)
			}

			// Verify the code is valid Go code by trying to format it
			tmpDir := t.TempDir()
			pkgFile := filepath.Join(tmpDir, "types.go")
			err = os.WriteFile(pkgFile, buf.Bytes(), 0644)
			require.NoError(t, err, "should write generated code to file")

			cmd := exec.Command("go", "fmt", pkgFile)
			output, err := cmd.CombinedOutput()
			require.NoError(t, err, "generated code should be valid Go code: %s", string(output))
		})
	}
}
