package generator

import (
	"bytes"
	"context"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/walteh/gotmpls/gen/jsonschema/go/vscodemetamodel"
	"gitlab.com/tozd/go/errors"
)

// FileGenerator handles generating Go files
type FileGenerator struct {
	namer *TypeNamer
	model *vscodemetamodel.MetaModel
}

// NewFileGenerator creates a new file generator
func NewFileGenerator(model *vscodemetamodel.MetaModel) *FileGenerator {
	return &FileGenerator{
		namer: NewTypeNamer(),
		model: model,
	}
}

// FileOutput represents a generated file
type FileOutput struct {
	Path     string // Relative path to write the file
	Contents string // File contents
}

// GenerateFiles generates all Go files for the types
func (g *FileGenerator) GenerateFiles(ctx context.Context, packageName string) ([]FileOutput, error) {
	var files []FileOutput

	// Generate types file
	typesFile, err := g.generateTypesFile(ctx, packageName)
	if err != nil {
		return nil, errors.Errorf("generating types file: %w", err)
	}
	files = append(files, typesFile)

	// TODO(lsproto): ğŸ¯ Generate additional files:
	// - Package documentation
	// - Constants
	// - Interfaces
	// - Utils

	return files, nil
}

// generateTypesFile generates the main types file
func (g *FileGenerator) generateTypesFile(ctx context.Context, packageName string) (FileOutput, error) {
	// Get all types in dependency order
	types, err := g.getSortedTypes()
	if err != nil {
		return FileOutput{}, errors.Errorf("getting sorted types: %w", err)
	}

	// Generate file contents
	var buf bytes.Buffer

	// File header
	header := fmt.Sprintf(`// Code generated by lsproto-gen. DO NOT EDIT.

package %s

import (
	"encoding/json"
	"fmt"

	"gitlab.com/tozd/go/errors"
)

`, packageName)
	buf.WriteString(header)

	// Generate each type
	for _, typeInfo := range types {
		// Add type documentation
		if typeInfo.Documentation != "" {
			buf.WriteString(fmt.Sprintf("// %s\n", typeInfo.Documentation))
		}

		// Add ASCII art separator for visual clarity
		buf.WriteString("//\n")
		buf.WriteString("// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n")
		buf.WriteString(fmt.Sprintf("// â”‚ %-60s â”‚\n", typeInfo.Name))
		buf.WriteString("// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n")
		buf.WriteString("//\n")

		// Add type definition
		if err := g.generateTypeDefinition(&buf, typeInfo); err != nil {
			return FileOutput{}, errors.Errorf("generating type definition for %s: %w", typeInfo.Name, err)
		}

		// Add methods
		if err := g.generateTypeMethods(&buf, typeInfo); err != nil {
			return FileOutput{}, errors.Errorf("generating type methods for %s: %w", typeInfo.Name, err)
		}

		// Add newline between types
		buf.WriteString("\n")
	}

	return FileOutput{
		Path:     filepath.Join("types.go"),
		Contents: buf.String(),
	}, nil
}

// getSortedTypes returns all types sorted by dependencies
func (g *FileGenerator) getSortedTypes() ([]TypeInfo, error) {
	// Process enumerations first
	for _, enumeration := range g.model.Enumerations {
		// Create type info for the enumeration
		info := TypeInfo{
			Name:          enumeration.Name,
			GoType:        "uint32", // All enums are uint32
			IsPointer:     false,
			IsBuiltin:     true,
			IsNullable:    false,
			Documentation: stringPtrToString(enumeration.Documentation),
		}

		// Store the type info
		g.namer.knownTypes[info.Name] = info
	}

	// Process structures next
	for _, structure := range g.model.Structures {
		// Create type info for the structure
		info := TypeInfo{
			Name:          structure.Name,
			GoType:        structure.Name,
			IsPointer:     false,
			IsBuiltin:     false,
			IsNullable:    false,
			Documentation: stringPtrToString(structure.Documentation),
		}

		// Add dependencies from properties
		for _, prop := range structure.Properties {
			propInfo, err := g.namer.GetTypeInfo(prop.Type)
			if err != nil {
				return nil, errors.Errorf("getting type info for property %s: %w", prop.Name, err)
			}
			info.Dependencies = append(info.Dependencies, propInfo.Name)
		}

		// Store the type info
		g.namer.knownTypes[info.Name] = info
	}

	// Process type aliases and unions
	for _, typeAlias := range g.model.TypeAliases {
		// Get type info
		info, err := g.namer.GetTypeInfo(typeAlias.Type)
		if err != nil {
			return nil, errors.Errorf("getting type info for %s: %w", typeAlias.Name, err)
		}

		// Override the name from the metamodel
		info.Name = typeAlias.Name
		info.Documentation = stringPtrToString(typeAlias.Documentation)

		// Store the type info
		g.namer.knownTypes[info.Name] = info
	}

	// Get dependency graph
	graph := g.namer.GetDependencyGraph()

	// Convert to list and sort
	var types []TypeInfo
	for name := range graph {
		info, ok := g.namer.knownTypes[name]
		if !ok {
			return nil, errors.Errorf("type %s not found in known types", name)
		}
		types = append(types, info)
	}

	// Sort by dependencies (types with no deps first)
	sort.Slice(types, func(i, j int) bool {
		return len(types[i].Dependencies) < len(types[j].Dependencies)
	})

	return types, nil
}

// Helper function to convert *string to string
func stringPtrToString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

// generateTypeDefinition generates the type definition
func (g *FileGenerator) generateTypeDefinition(buf *bytes.Buffer, info TypeInfo) error {
	// Skip built-in types
	if info.IsBuiltin {
		return nil
	}

	// If this is an array type, we don't need to generate a definition
	if strings.HasPrefix(info.Name, "[]") {
		return nil
	}

	// Find the corresponding structure
	var structure *vscodemetamodel.Structure
	for i := range g.model.Structures {
		if g.model.Structures[i].Name == info.Name {
			structure = &g.model.Structures[i]
			break
		}
	}

	// If not a structure, check if it's an enumeration
	if structure == nil {
		for _, enum := range g.model.Enumerations {
			if enum.Name == info.Name {
				// Generate enum type
				buf.WriteString(fmt.Sprintf("type %s uint32\n\n", info.Name))
				buf.WriteString("const (\n")
				for _, value := range enum.Values {
					buf.WriteString(fmt.Sprintf("\t%s_%s %s = %d // %s\n",
						info.Name, value.Name, info.Name, value.Value,
						stringPtrToString(value.Documentation)))
				}
				buf.WriteString(")\n")
				return nil
			}
		}
		return errors.Errorf("type %s not found in structures or enumerations", info.Name)
	}

	// Define template data
	type Field struct {
		Name    string
		Type    string
		Tag     string
		Comment string
	}

	type TemplateData struct {
		Name   string
		Fields []Field
	}

	// Create template data
	data := TemplateData{
		Name: info.Name,
	}

	// Add fields from structure properties
	for _, prop := range structure.Properties {
		propInfo, err := g.namer.GetTypeInfo(prop.Type)
		if err != nil {
			return errors.Errorf("getting type info for property %s: %w", prop.Name, err)
		}

		// Capitalize first letter of field name
		fieldName := strings.ToUpper(prop.Name[:1]) + prop.Name[1:]

		field := Field{
			Name:    fieldName,
			Type:    propInfo.GoType,
			Tag:     fmt.Sprintf("`json:\"%s\" yaml:\"%s\" mapstructure:\"%s\"`", prop.Name, prop.Name, prop.Name),
			Comment: stringPtrToString(prop.Documentation),
		}
		data.Fields = append(data.Fields, field)
	}

	// Parse and execute template
	tmpl := template.Must(template.New("type").Parse(`
// {{.Name}} represents a type in the LSP protocol.
type {{.Name}} struct {
	{{- range .Fields}}
	{{.Name}} {{.Type}} {{.Tag}} // {{.Comment}}
	{{- end}}
}
`))

	if err := tmpl.Execute(buf, data); err != nil {
		return errors.Errorf("executing template: %w", err)
	}

	return nil
}

// generateTypeMethods generates the type methods
func (g *FileGenerator) generateTypeMethods(buf *bytes.Buffer, info TypeInfo) error {
	// Skip non-union types
	if !info.IsUnion {
		return nil
	}

	// Define template data
	type Field struct {
		Name    string
		Type    string
		VarName string // Variable name for the field (e.g., v for value)
	}

	type TemplateData struct {
		Name   string
		Fields []Field
	}

	// Create template data
	data := TemplateData{
		Name: info.Name,
	}

	// Add fields based on type info
	for _, dep := range info.Dependencies {
		depInfo, ok := g.namer.knownTypes[dep]
		if !ok {
			return errors.Errorf("dependency %s not found in known types", dep)
		}

		field := Field{
			Name:    fmt.Sprintf("%sValue", depInfo.Name),
			Type:    depInfo.GoType,
			VarName: "v",
		}
		data.Fields = append(data.Fields, field)
	}

	// Parse and execute template
	tmpl := template.Must(template.New("methods").Parse(`
// Validate ensures exactly one field is set
func (t *{{.Name}}) Validate() error {
	count := 0
	{{- range .Fields}}
	if t.{{.Name}} != nil { count++ }
	{{- end}}
	if count != 1 {
		return errors.New("exactly one field must be set")
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (t {{.Name}}) MarshalJSON() ([]byte, error) {
	if err := t.Validate(); err != nil {
		return nil, err
	}

	{{- range .Fields}}
	if t.{{.Name}} != nil {
		return json.Marshal(*t.{{.Name}})
	}
	{{- end}}

	return nil, errors.New("no field set")
}

// UnmarshalJSON implements json.Unmarshaler
func (t *{{.Name}}) UnmarshalJSON(data []byte) error {
	{{- range .Fields}}
	// Try {{.Type}}
	var {{.VarName}} {{.Type}}
	if err := json.Unmarshal(data, &{{.VarName}}); err == nil {
		t.{{.Name}} = &{{.VarName}}
		return nil
	}
	{{- end}}

	return errors.New("data matches no expected type")
}
`))

	if err := tmpl.Execute(buf, data); err != nil {
		return errors.Errorf("executing template: %w", err)
	}

	return nil
}
