package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/bmatcuk/doublestar/v4"
	"gitlab.com/tozd/go/errors"
)

var (
	processedFiles sync.Map
	loggerMu       sync.Mutex
)

func logFileOperation(ctx context.Context, opts FileInfo) {
	logger := loggerFromContext(ctx)
	logger.LogFileOperation(opts)
	// if _, loaded := processedFiles.LoadOrStore(opts.Name, true); !loaded {
	// 	loggerMu.Lock()
	// 	defer loggerMu.Unlock()

	// 	logger.LogFileOperation(opts)
	// }
}

// üßπ Clean destination directory
func cleanDestination(ctx context.Context, status *StatusFile, destPath string) error {
	logger := loggerFromContext(ctx)

	for _, entry := range status.CoppiedFiles {
		logger.AddFileOperation(FileInfo{Name: entry.File, IsRemoved: true})
		if err := os.Remove(filepath.Join(destPath, entry.File)); err != nil {
			return errors.Errorf("removing file: %w", err)
		}
	}

	for _, entry := range status.GeneratedFiles {
		logger.AddFileOperation(FileInfo{Name: entry.File, IsRemoved: true})
		if err := os.Remove(filepath.Join(destPath, entry.File)); err != nil {
			return errors.Errorf("removing file: %w", err)
		}
	}

	logger.AddFileOperation(FileInfo{Name: ".copyrc.lock", IsRemoved: true})
	if err := os.Remove(filepath.Join(destPath, ".copyrc.lock")); err != nil {
		if !os.IsNotExist(err) {
			return errors.Errorf("removing status file: %w", err)
		}
	}

	return nil
}

func processFile(ctx context.Context, provider RepoProvider, cfg *Config, file, commitHash string, status *StatusFile, mu *sync.Mutex, destPath string) error {

	if cfg.ArchiveArgs != nil {
		if cfg.ProviderArgs.Path != "" {
			return errors.New("path is not supported in tarball mode")
		}

		// Ensure cache directory exists
		repoName := filepath.Base(cfg.ProviderArgs.Repo)
		if err := os.MkdirAll(destPath, 0755); err != nil {
			return errors.Errorf("creating repo directory: %w", err)
		}

		// Download tarball
		data, err := GetFileFromTarball(ctx, provider, cfg.ProviderArgs)
		if err != nil {
			return errors.Errorf("getting file from tarball: %w", err)
		}
		tarballPath := filepath.Join(destPath, repoName+".tar.gz")

		// Save tarball
		sourceInfo, err := provider.GetSourceInfo(ctx, cfg.ProviderArgs, commitHash)
		if err != nil {
			return errors.Errorf("getting source info: %w", err)
		}

		permalink, err := provider.GetArchiveUrl(ctx, cfg.ProviderArgs)
		if err != nil {
			return errors.Errorf("getting permalink: %w", err)
		}

		// Let writeFile handle status determination
		if _, err := writeFile(ctx, WriteFileOpts{
			Path:        tarballPath,
			Contents:    data,
			StatusFile:  status,
			StatusMutex: mu,
			Source:      sourceInfo,
			Permalink:   permalink,
		}); err != nil {
			return errors.Errorf("writing tarball: %w", err)
		}

		if cfg.ArchiveArgs.GoEmbed {

			mu.Lock()
			tarStatus := status.CoppiedFiles[filepath.Base(tarballPath)]
			mu.Unlock()

			// Create embed.go file
			pkgName := strings.ReplaceAll(repoName, "-", "")
			embedPath := filepath.Join(destPath, "embed.gen.go")
			var buf bytes.Buffer

			fmt.Fprintf(&buf, "// üì¶ generated by copyrc. DO NOT EDIT.\n")
			fmt.Fprintf(&buf, "// ‚ÑπÔ∏è see .copyrc.lock for more details.\n\n")
			fmt.Fprintf(&buf, "package %s\n\n", pkgName)
			fmt.Fprintf(&buf, "import _ \"embed\"\n\n")
			fmt.Fprintf(&buf, "//go:embed %s.tar.gz\n", repoName)
			fmt.Fprintf(&buf, "var Data []byte\n\n")
			fmt.Fprintf(&buf, "// Metadata about the downloaded repository\n")
			fmt.Fprintf(&buf, "var (\n")
			fmt.Fprintf(&buf, "\tRef        = %q\n", cfg.ProviderArgs.Ref)
			fmt.Fprintf(&buf, "\tCommit     = %q\n", commitHash)
			fmt.Fprintf(&buf, "\tRepository = %q\n", cfg.ProviderArgs.Repo)
			fmt.Fprintf(&buf, "\tPermalink  = %q\n", permalink)
			fmt.Fprintf(&buf, "\tDownloaded = %q\n", tarStatus.LastUpdated.Format(time.RFC3339))
			fmt.Fprintf(&buf, ")\n")

			// Let writeFile handle status determination
			if _, err := writeFile(ctx, WriteFileOpts{
				Path:          embedPath,
				Contents:      buf.Bytes(),
				IsManaged:     true,
				StatusFile:    status,
				StatusMutex:   mu,
				EnsureNewline: true,
			}); err != nil {
				return errors.Errorf("writing embed.gen.go: %w", err)
			}

		}

		return nil
	}

	if cfg.CopyArgs == nil {
		return errors.New("copy args are required")
	}

	sourceInfo, err := provider.GetSourceInfo(ctx, cfg.ProviderArgs, commitHash)
	if err != nil {
		return errors.Errorf("getting source info: %w", err)
	}

	permalink, err := provider.GetPermalink(ctx, cfg.ProviderArgs, commitHash, file)
	if err != nil {
		return errors.Errorf("getting permalink: %w", err)
	}

	var contentz []byte
	if mockProvider, ok := provider.(*MockProvider); ok {
		// For mock provider, use GetFile directly
		contentz, err = mockProvider.GetFile(ctx, cfg.ProviderArgs, file)
		if err != nil {
			return errors.Errorf("getting file content: %w", err)
		}
	} else if strings.HasPrefix(permalink, "file://") {
		contentz, err = os.ReadFile(strings.TrimPrefix(permalink, "file://"))
		if err != nil {
			return errors.Errorf("reading file: %w", err)
		}
	} else {
		req, err := http.NewRequestWithContext(ctx, "GET", permalink, nil)
		if err != nil {
			return errors.Errorf("creating request: %w", err)
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return errors.Errorf("downloading file: %w", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			return errors.Errorf("downloading file: %s", resp.Status)
		}

		contentz, err = io.ReadAll(resp.Body)
		if err != nil {
			return errors.Errorf("reading file: %w", err)
		}
	}

	// Get base name and extension
	ext := filepath.Ext(file)
	base := strings.TrimSuffix(filepath.Base(file), ext)

	// Process content
	var buf bytes.Buffer

	// Add file header based on extension
	switch ext {
	case ".go", ".js", ".ts", ".jsx", ".tsx", ".cpp", ".c", ".h", ".hpp", ".java", ".scala", ".rs", ".php", "jsonc":
		fmt.Fprintf(&buf, "// üì¶ generated by copyrc. DO NOT EDIT.\n")
		fmt.Fprintf(&buf, "// üîó source: %s\n", permalink)
		fmt.Fprintf(&buf, "// ‚ÑπÔ∏è see .copyrc.lock for more details.\n\n")
	case ".py", ".rb", ".pl", ".sh", ".yaml", ".yml":
		fmt.Fprintf(&buf, "# üì¶ generated by copyrc. DO NOT EDIT.\n")
		fmt.Fprintf(&buf, "# üîó source: %s\n", permalink)
		fmt.Fprintf(&buf, "# ‚ÑπÔ∏è see .copyrc.lock for more details.\n\n")
	case ".md", ".xml":
		fmt.Fprintf(&buf, "<!--\n")
		fmt.Fprintf(&buf, "üì¶ generated by copyrc. DO NOT EDIT.\n")
		fmt.Fprintf(&buf, "üîó source: %s\n", permalink)
		fmt.Fprintf(&buf, "‚ÑπÔ∏è see .copyrc.lock for more details.\n")
		fmt.Fprintf(&buf, "-->\n\n")
	}

	// Write original content
	buf.Write(contentz)

	// Apply replacements
	var replacementCount int
	var changes []string
	for _, r := range cfg.CopyArgs.Replacements {
		if r.File != nil && *r.File != "" {
			matched, err := doublestar.Match(*r.File, file)
			if err != nil {
				return errors.Errorf("matching file: %w", err)
			}
			if !matched {
				continue
			}
		}
		if bytes.Contains(buf.Bytes(), []byte(r.Old)) {
			// Count occurrences of the replacement
			replacementCount += bytes.Count(buf.Bytes(), []byte(r.Old))

			// Find line numbers for the changes
			lines := bytes.Split(buf.Bytes(), []byte("\n"))
			for i, line := range lines {
				if bytes.Contains(line, []byte(r.Old)) {
					change := fmt.Sprintf("Line %d: Replaced '%s' with '%s'", i+1, r.Old, r.New)
					changes = append(changes, change)
				}
			}

			// Apply the replacement
			newContent := bytes.ReplaceAll(buf.Bytes(), []byte(r.Old), []byte(r.New))
			buf.Reset()
			buf.Write(newContent)
		}
	}

	// Check if file exists and has .patch suffix
	outPath := filepath.Join(cfg.DestPath, base+".copy"+ext)

	// Let writeFile handle all status management and logging
	if _, err := writeFile(ctx, WriteFileOpts{
		Path:             outPath,
		Contents:         buf.Bytes(),
		StatusFile:       status,
		StatusMutex:      mu,
		Source:           sourceInfo,
		Permalink:        permalink,
		Changes:          changes,
		ReplacementCount: replacementCount,
		EnsureNewline:    true,
	}); err != nil {
		return errors.Errorf("writing file: %w", err)
	}

	return nil
}

func processDirectory(ctx context.Context, provider RepoProvider, cfg *Config, commitHash string, status *StatusFile, mu *sync.Mutex, destPath string) error {
	var files []string
	var err error
	if cfg.ArchiveArgs == nil {
		// Get list of files from provider
		files, err = provider.ListFiles(ctx, cfg.ProviderArgs)
		if err != nil {
			return errors.Errorf("listing files: %w", err)
		}
	} else {
		files = []string{""}
	}

	// Sort files by name
	sort.Strings(files)

	// Process each file
	if cfg.Async {
		var wg sync.WaitGroup
		errChan := make(chan error, len(files))

		for _, file := range files {
			wg.Add(1)
			go func(f string) {
				defer wg.Done()
				if err := processFile(ctx, provider, cfg, f, commitHash, status, mu, destPath); err != nil {
					errChan <- errors.Errorf("processing file %s: %w", f, err)
				}
			}(file)
		}

		// Wait for all goroutines to finish
		wg.Wait()
		close(errChan)

		// Check for errors
		for err := range errChan {
			if err != nil {
				return err
			}
		}
	} else {
		for _, file := range files {
			if file == "" && cfg.ArchiveArgs == nil {
				continue
			}
			if err := processFile(ctx, provider, cfg, file, commitHash, status, mu, destPath); err != nil {
				return errors.Errorf("processing file %s: %w", file, err)
			}
		}
	}

	var dirPath string
	if cfg.ArchiveArgs != nil {
		dirPath = filepath.Join(cfg.DestPath, filepath.Base(cfg.ProviderArgs.Repo))
	} else {
		dirPath = cfg.DestPath
	}

	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return errors.Errorf("reading directory: %w", err)
	}

	entries = slices.DeleteFunc(entries, func(entry os.DirEntry) bool {
		_, genStatus := status.GeneratedFiles[entry.Name()]
		_, copyStatus := status.CoppiedFiles[entry.Name()]
		return genStatus || copyStatus || entry.IsDir() || entry.Name() == ".copyrc.lock" || entry.Name() == ".git" || entry.Name() == ".DS_Store"
	})

	slices.SortFunc(entries, func(a, b os.DirEntry) int {
		return strings.Compare(a.Name(), b.Name())
	})

	for _, entry := range entries {
		if _, err := writeFile(ctx, WriteFileOpts{
			Path:        filepath.Join(dirPath, entry.Name()),
			IsUntracked: true,
		}); err != nil {
			return errors.Errorf("writing untracked file: %w", err)
		}
	}

	return nil
}
