#!/bin/bash

# 📚 Documentation
# ===============
# This script syncs Go files from a GitHub repository and applies custom transformations
#
# Features:
# 🔍 Downloads specific Go files from a GitHub repository
# 🛠️ Applies custom string replacements
# 📦 Adds package declarations if missing
# ✨ Handles nested directory structures
#
# Usage:
#   ./sync-go-files.sh <github-url> <destination-dir> [--string-to-replace <pattern>]
#
# Arguments:
#   github-url           : GitHub URL in format github.com/ORG/REPO/blob/BRANCH/PATH (required)
#   destination-dir      : Local directory to sync files to (required)
#   --string-to-replace : Pattern to replace in format 'old:new' (optional, multiple allowed)
#
# Example:
#   ./sync-go-files.sh \
#     github.com/golang/tools/blob/master/gopls/internal/protocol/generate \
#     ./pkg/lsp/generator \
#     --string-to-replace 'func main():func main_original()'

set -euo pipefail

# 🔍 Validate required arguments
if [ "$#" -lt 2 ]; then

	echo "❌ Missing required arguments"
	echo "📖 Usage: $0 <github-url> <destination-dir> [--string-to-replace <pattern>]"
	echo "   Example: $0 github.com/golang/tools/blob/master/gopls/internal/protocol/generate ./pkg/lsp/generator"
	exit 1
fi

# 🎯 Parse initial arguments
GITHUB_URL=$1
DEST_DIR=$2
shift 2

# 🔄 Parse GitHub URL components
if [[ ! "$GITHUB_URL" =~ ^github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+)$ ]]; then
	echo "❌ Invalid GitHub URL format"
	echo "📖 Expected: github.com/ORG/REPO/blob/BRANCH/PATH"
	exit 1
fi

ORG="${BASH_REMATCH[1]}"
REPO="${BASH_REMATCH[2]}"
BRANCH="${BASH_REMATCH[3]}"
SOURCE_PATH="${BASH_REMATCH[4]}"

# 📝 Store string replacements
STRINGS_TO_REPLACE=()
FILES_TO_IGNORE=()
while [[ $# -gt 0 ]]; do
	case "$1" in
	--string-to-replace)
		if [[ $# -lt 2 ]]; then
			echo "❌ Error: --string-to-replace requires a pattern"
			exit 1
		fi
		STRINGS_TO_REPLACE+=("$2")
		shift 2
		;;
	--file-to-ignore)
		if [[ $# -lt 2 ]]; then
			echo "❌ Error: --file-to-ignore requires a pattern"
			exit 1
		fi
		FILES_TO_IGNORE+=("$2")
		shift 2
		;;
	*)
		echo "❌ Unknown argument: $1"
		exit 1
		;;
	esac
done

# 📋 Show configuration
echo "🔄 Syncing files from github.com/$ORG/$REPO"
echo "├── 🌿 Branch: $BRANCH"
echo "├── 📂 Source: $SOURCE_PATH"
echo "├── 🎯 Destination: $DEST_DIR"
echo "├── 🔧 Replacements: ${STRINGS_TO_REPLACE[*]:-none}"
echo "└── 🫥 Files to ignore: ${FILES_TO_IGNORE[*]:-none}"
# 📁 Create destination directory
mkdir -p "$DEST_DIR"

# Create status file if it doesn't exist
STATUS_FILE="$DEST_DIR/.copy-status"
if [ ! -f "$STATUS_FILE" ]; then
	printf "# 📦 Copy Status File\n" >"$STATUS_FILE"
	printf "# 📝 Tracks changes made to copied files\n" >>"$STATUS_FILE"
	printf "# ⚠️  Do not edit this file manually\n\n" >>"$STATUS_FILE"
fi

# 📥 Get list of .go files from the directory
echo "🔍 Fetching file list..."
FILES=$(curl -s "https://api.github.com/repos/$ORG/$REPO/contents/$SOURCE_PATH?ref=$BRANCH" | grep "\"path\"" | cut -d '"' -f 4)

# 🔍 Filter out files to ignore
echo "🔍 Filtering out files to ignore..."
# if we have files to ignore, filter them out (don't throw unbound variable error)
if [ ${#FILES_TO_IGNORE[@]} -gt 0 ]; then
	for file in "${FILES_TO_IGNORE[@]}"; do
		FILES=$(echo "$FILES" | grep -vE "$file")
	done
fi

if [ -z "$FILES" ]; then
	echo "❌ No files found in the specified directory"
	exit 1
fi

# Clear the status file but keep the header (first 4 lines)
head -n 4 "$STATUS_FILE" >"$STATUS_FILE.tmp"
mv "$STATUS_FILE.tmp" "$STATUS_FILE"

# 📦 Download and process each file
for file in $FILES; do
	filename=$(basename "$file")
	extension="${filename##*.}"
	basename="${filename%.*}"

	# Set output filename (always .copy)
	output_filename="${basename}.copy.${extension}"

	echo "📥 Processing $filename -> $output_filename..."

	# Get commit info
	COMMIT_HASH=$(curl -s "https://api.github.com/repos/$ORG/$REPO/commits/$BRANCH" | grep -o '"sha": "[^"]*' | head -1 | cut -d'"' -f4)
	PERMALINK="https://github.com/$ORG/$REPO/blob/$COMMIT_HASH/$file"
	DOWNLOAD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

	# Create temporary file for processing
	temp_file=$(mktemp)

	# Download file
	if ! curl -fL --progress-bar "https://raw.githubusercontent.com/$ORG/$REPO/$BRANCH/$file" -o "$temp_file"; then
		echo "❌ Failed to download $filename"
		rm -f "$temp_file"
		exit 1
	fi

	# Verify file
	if [ ! -s "$temp_file" ]; then
		echo "❌ Downloaded file $filename is empty"
		rm -f "$temp_file"
		exit 1
	fi

	# Create the final file with appropriate header
	final_file="$DEST_DIR/$output_filename"

	# Start building status entry
	{
		echo "## File: $output_filename"
		echo "- 📦 Source: github.com/$ORG/$REPO@$COMMIT_HASH"
		echo "- 🔗 Permalink: $PERMALINK"
		echo "- ⏰ Downloaded: $DOWNLOAD_TIME"
		echo "- 📝 Changes:"
	} >>"$STATUS_FILE"

	# Add source information based on file type
	case "$extension" in
	go | js | ts | jsx | tsx | cpp | c | h | hpp | java | scala | rs | php)
		# Languages that use // comments
		cat >"$final_file" <<-EOF
			// 📦 Generated from: github.com/$ORG/$REPO
			// 🔗 Source: $PERMALINK
			// ⏰ Downloaded at: $DOWNLOAD_TIME
			// ⚠️  This file is auto-generated. See .copy-status for details.

		EOF
		;;
	py | rb | pl | sh)
		# Languages that use # comments
		cat >"$final_file" <<-EOF
			# 📦 Generated from: github.com/$ORG/$REPO
			# 🔗 Source: $PERMALINK
			# ⏰ Downloaded at: $DOWNLOAD_TIME
			# ⚠️  This file is auto-generated. See .copy-status for details.

		EOF
		;;
	md | txt | json | yaml | yml)
		# Files that don't support comments, add a header block
		cat >"$final_file" <<-EOF
			<!--
			📦 Generated from: github.com/$ORG/$REPO
			🔗 Source: $PERMALINK
			⏰ Downloaded at: $DOWNLOAD_TIME
			⚠️  This file is auto-generated. See .copy-status for details.
			-->

		EOF
		;;
	*)
		# For unknown file types, just create an empty file
		touch "$final_file"
		;;
	esac

	# Add package declaration if it's a Go file and missing one
	if [[ "$extension" == "go" ]] && ! grep -q "^package" "$temp_file"; then
		PACKAGE_NAME=$(basename "$DEST_DIR")
		echo "📝 Adding package declaration: $PACKAGE_NAME"
		echo "package ${PACKAGE_NAME}" >>"$final_file"
		echo "" >>"$final_file"
		echo "  - Added package declaration: $PACKAGE_NAME" >>"$STATUS_FILE"
	fi

	# Append the file contents
	cat "$temp_file" >>"$final_file"

	# Apply string replacements if needed (only for Go files)
	if [ ${#STRINGS_TO_REPLACE[@]} -gt 0 ] && [[ "$extension" == "go" ]]; then
		for pattern in "${STRINGS_TO_REPLACE[@]}"; do
			if [[ "$pattern" =~ ^([^:]+):([^:]*)$ ]]; then
				old="${BASH_REMATCH[1]}"
				new="${BASH_REMATCH[2]}"
				echo "🔧 Replacing '$old' with '$new'"

				# Get line numbers where replacements will occur
				line_nums=$(grep -n "$old" "$final_file" | cut -d: -f1)
				if [ ! -z "$line_nums" ]; then
					# Use perl for the replacement (better handling of special characters)
					perl -pi -e "s/\Q$old\E/$new/g" "$final_file"

					# Record the changes
					while IFS= read -r line; do
						echo "  - Line $line: Replaced '$old' with '$new'" >>"$STATUS_FILE"
					done <<<"$line_nums"
				fi
			else
				echo "⚠️  Invalid replacement pattern: '$pattern', skipping"
			fi
		done
	fi

	# Add separator
	echo "---" >>"$STATUS_FILE"

	# Cleanup
	rm -f "$temp_file"
done

echo "✅ Successfully synced all files to $DEST_DIR"
echo "📝 See $STATUS_FILE for detailed change information"
