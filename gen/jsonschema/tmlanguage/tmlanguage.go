// Code generated by schema-generate. DO NOT EDIT.

package tmlanguage

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Root
type Root interface{}

// Captures 
type Captures struct {
}

// Grammar 
type Grammar struct {
  Patterns []*Pattern `json:"patterns"`

  // a dictionary (i.e. key/value pairs) of rules which can be included from other places in the grammar. The key is the name of the rule and the value is the actual rule. Further explanation (and example) follow with the description of the include rule key.
  Repository map[string]*Pattern `json:"repository,omitempty"`
}

// Pattern 
type Pattern struct {
  ApplyEndPatternLast int `json:"applyEndPatternLast,omitempty"`

  // these keys allow matches which span several lines and must both be mutually exclusive with the match key. Each is a regular expression pattern. begin is the pattern that starts the block and end is the pattern which ends the block. Captures from the begin pattern can be referenced in the end pattern by using normal regular expression back-references. This is often used with here-docs. A begin/end rule can have nested patterns using the patterns key.
  Begin string `json:"begin,omitempty"`

  // allows you to assign attributes to the captures of the begin pattern. Using the captures key for a begin/end rule is short-hand for giving both beginCaptures and endCaptures with same values.
  BeginCaptures *Captures `json:"beginCaptures,omitempty"`

  // allows you to assign attributes to the captures of the match pattern. Using the captures key for a begin/end rule is short-hand for giving both beginCaptures and endCaptures with same values.
  Captures *Captures `json:"captures,omitempty"`
  Comment string `json:"comment,omitempty"`

  // this key is similar to the name key but only assigns the name to the text between what is matched by the begin/end patterns.
  ContentName interface{} `json:"contentName,omitempty"`

  // set this property to 1 to disable the current pattern
  Disabled int `json:"disabled,omitempty"`

  // these keys allow matches which span several lines and must both be mutually exclusive with the match key. Each is a regular expression pattern. begin is the pattern that starts the block and end is the pattern which ends the block. Captures from the begin pattern can be referenced in the end pattern by using normal regular expression back-references. This is often used with here-docs. A begin/end rule can have nested patterns using the patterns key.
  End string `json:"end,omitempty"`

  // allows you to assign attributes to the captures of the end pattern. Using the captures key for a begin/end rule is short-hand for giving both beginCaptures and endCaptures with same values.
  EndCaptures *Captures `json:"endCaptures,omitempty"`

  // this allows you to reference a different language, recursively reference the grammar itself or a rule declared in this file's repository.
  Include string `json:"include,omitempty"`

  // a regular expression which is used to identify the portion of text to which the name should be assigned. Example: '\b(true|false)\b'.
  Match string `json:"match,omitempty"`

  // the name which gets assigned to the portion matched. This is used for styling and scope-specific settings and actions, which means it should generally be derived from one of the standard names.
  Name interface{} `json:"name,omitempty"`

  // applies to the region between the begin and end matches
  Patterns []*Pattern `json:"patterns,omitempty"`

  // these keys allow matches which span several lines and must both be mutually exclusive with the match key. Each is a regular expression pattern. begin is the pattern that starts the block and while continues it.
  While string `json:"while,omitempty"`

  // allows you to assign attributes to the captures of the while pattern. Using the captures key for a begin/while rule is short-hand for giving both beginCaptures and whileCaptures with same values.
  WhileCaptures *Captures `json:"whileCaptures,omitempty"`
}

func (strct *Captures) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Captures) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Grammar) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Patterns" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "patterns" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"patterns\": ")
	if tmp, err := json.Marshal(strct.Patterns); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "repository" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"repository\": ")
	if tmp, err := json.Marshal(strct.Repository); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Grammar) UnmarshalJSON(b []byte) error {
    patternsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "patterns":
            if err := json.Unmarshal([]byte(v), &strct.Patterns); err != nil {
                return err
             }
            patternsReceived = true
        case "repository":
            if err := json.Unmarshal([]byte(v), &strct.Repository); err != nil {
                return err
             }
        }
    }
    // check if patterns (a required property) was received
    if !patternsReceived {
        return errors.New("\"patterns\" is required but was not present")
    }
    return nil
}
