// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package vscodemetamodel

import "encoding/json"
import "fmt"
import "reflect"

// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
type AndType struct {
	// Items corresponds to the JSON schema field "items".
	Items []AndTypeItemsElem `json:"items" yaml:"items" mapstructure:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`
}

type AndTypeItemsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AndType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in AndType: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in AndType: required")
	}
	type Plain AndType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AndType(plain)
	return nil
}

// Represents an array type (e.g. `TextDocument[]`).
type ArrayType struct {
	// Element corresponds to the JSON schema field "element".
	Element ArrayTypeElement `json:"element" yaml:"element" mapstructure:"element"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`
}

type ArrayTypeElement interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArrayType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["element"]; raw != nil && !ok {
		return fmt.Errorf("field element in ArrayType: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in ArrayType: required")
	}
	type Plain ArrayType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ArrayType(plain)
	return nil
}

// Represents a base type like `string` or `DocumentUri`.
type BaseType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name BaseTypes `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in BaseType: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in BaseType: required")
	}
	type Plain BaseType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BaseType(plain)
	return nil
}

type BaseTypes string

const BaseTypesBoolean BaseTypes = "boolean"
const BaseTypesDecimal BaseTypes = "decimal"
const BaseTypesDocumentUri BaseTypes = "DocumentUri"
const BaseTypesInteger BaseTypes = "integer"
const BaseTypesNull BaseTypes = "null"
const BaseTypesRegExp BaseTypes = "RegExp"
const BaseTypesString BaseTypes = "string"
const BaseTypesURI BaseTypes = "URI"
const BaseTypesUinteger BaseTypes = "uinteger"

var enumValues_BaseTypes = []interface{}{
	"URI",
	"DocumentUri",
	"integer",
	"uinteger",
	"decimal",
	"RegExp",
	"string",
	"boolean",
	"null",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BaseTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BaseTypes, v)
	}
	*j = BaseTypes(v)
	return nil
}

// Represents a boolean literal type (e.g. `kind: true`).
type BooleanLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value bool `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BooleanLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in BooleanLiteralType: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in BooleanLiteralType: required")
	}
	type Plain BooleanLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BooleanLiteralType(plain)
	return nil
}

// Defines an enumeration.
type Enumeration struct {
	// Whether the enumeration is deprecated or not. If deprecated the property
	// contains the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation.
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The name of the enumeration.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether this is a proposed enumeration. If omitted, the enumeration is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this enumeration is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// Whether the enumeration supports custom values (e.g. values which are not part
	// of the set defined in `values`). If omitted no custom values are supported.
	SupportsCustomValues *bool `json:"supportsCustomValues,omitempty" yaml:"supportsCustomValues,omitempty" mapstructure:"supportsCustomValues,omitempty"`

	// The type of the elements.
	Type EnumerationType `json:"type" yaml:"type" mapstructure:"type"`

	// The enum values.
	Values []EnumerationEntry `json:"values" yaml:"values" mapstructure:"values"`
}

// Defines an enumeration entry.
type EnumerationEntry struct {
	// Whether the enum entry is deprecated or not. If deprecated the property
	// contains the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation.
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The name of the enum item.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether this is a proposed enumeration entry. If omitted, the enumeration entry
	// is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this enumeration entry is available. Is undefined
	// if not known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// The value.
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in EnumerationEntry: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in EnumerationEntry: required")
	}
	type Plain EnumerationEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnumerationEntry(plain)
	return nil
}

type EnumerationType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name EnumerationTypeName `json:"name" yaml:"name" mapstructure:"name"`
}

type EnumerationTypeName string

const EnumerationTypeNameInteger EnumerationTypeName = "integer"
const EnumerationTypeNameString EnumerationTypeName = "string"
const EnumerationTypeNameUinteger EnumerationTypeName = "uinteger"

var enumValues_EnumerationTypeName = []interface{}{
	"string",
	"integer",
	"uinteger",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationTypeName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnumerationTypeName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnumerationTypeName, v)
	}
	*j = EnumerationTypeName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in EnumerationType: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in EnumerationType: required")
	}
	type Plain EnumerationType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnumerationType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Enumeration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Enumeration: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Enumeration: required")
	}
	if _, ok := raw["values"]; raw != nil && !ok {
		return fmt.Errorf("field values in Enumeration: required")
	}
	type Plain Enumeration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Enumeration(plain)
	return nil
}

type IntegerLiteralType struct {
	// Represents an integer literal type (e.g. `kind: 1`).
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntegerLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in IntegerLiteralType: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in IntegerLiteralType: required")
	}
	type Plain IntegerLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IntegerLiteralType(plain)
	return nil
}

// Represents a type that can be used as a key in a map type. If a reference type
// is used then the type must either resolve to a `string` or `integer` type. (e.g.
// `type ChangeAnnotationIdentifier === string`).
type MapKeyType interface{}

// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V>
// { [key: K] => V; }`).
type MapType struct {
	// Key corresponds to the JSON schema field "key".
	Key MapTypeKey `json:"key" yaml:"key" mapstructure:"key"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value MapTypeValue `json:"value" yaml:"value" mapstructure:"value"`
}

type MapTypeKey interface{}

type MapTypeValue interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MapType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in MapType: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in MapType: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in MapType: required")
	}
	type Plain MapType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MapType(plain)
	return nil
}

type MessageDirection string

const MessageDirectionBoth MessageDirection = "both"
const MessageDirectionClientToServer MessageDirection = "clientToServer"
const MessageDirectionServerToClient MessageDirection = "serverToClient"

var enumValues_MessageDirection = []interface{}{
	"clientToServer",
	"serverToClient",
	"both",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageDirection, v)
	}
	*j = MessageDirection(v)
	return nil
}

type MetaData struct {
	// The protocol version.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetaData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in MetaData: required")
	}
	type Plain MetaData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetaData(plain)
	return nil
}

// The actual meta model.
type MetaModel struct {
	// The enumerations.
	Enumerations []Enumeration `json:"enumerations" yaml:"enumerations" mapstructure:"enumerations"`

	// Additional meta data.
	MetaData MetaData `json:"metaData" yaml:"metaData" mapstructure:"metaData"`

	// The notifications.
	Notifications []Notification `json:"notifications" yaml:"notifications" mapstructure:"notifications"`

	// The requests.
	Requests []Request `json:"requests" yaml:"requests" mapstructure:"requests"`

	// The structures.
	Structures []Structure `json:"structures" yaml:"structures" mapstructure:"structures"`

	// The type aliases.
	TypeAliases []TypeAlias `json:"typeAliases" yaml:"typeAliases" mapstructure:"typeAliases"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetaModel) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["enumerations"]; raw != nil && !ok {
		return fmt.Errorf("field enumerations in MetaModel: required")
	}
	if _, ok := raw["metaData"]; raw != nil && !ok {
		return fmt.Errorf("field metaData in MetaModel: required")
	}
	if _, ok := raw["notifications"]; raw != nil && !ok {
		return fmt.Errorf("field notifications in MetaModel: required")
	}
	if _, ok := raw["requests"]; raw != nil && !ok {
		return fmt.Errorf("field requests in MetaModel: required")
	}
	if _, ok := raw["structures"]; raw != nil && !ok {
		return fmt.Errorf("field structures in MetaModel: required")
	}
	if _, ok := raw["typeAliases"]; raw != nil && !ok {
		return fmt.Errorf("field typeAliases in MetaModel: required")
	}
	type Plain MetaModel
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetaModel(plain)
	return nil
}

// Represents a LSP notification
type Notification struct {
	// Whether the notification is deprecated or not. If deprecated the property
	// contains the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation;
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The direction in which this notification is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection" yaml:"messageDirection" mapstructure:"messageDirection"`

	// The notifications's method name.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameter type(s) if any.
	Params interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`

	// Whether this is a proposed notification. If omitted the notification is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Optional a dynamic registration method if it different from the notifications's
	// method.
	RegistrationMethod *string `json:"registrationMethod,omitempty" yaml:"registrationMethod,omitempty" mapstructure:"registrationMethod,omitempty"`

	// Optional registration options if the notification supports dynamic
	// registration.
	RegistrationOptions NotificationRegistrationOptions `json:"registrationOptions,omitempty" yaml:"registrationOptions,omitempty" mapstructure:"registrationOptions,omitempty"`

	// Since when (release number) this notification is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// The type name of the notifications if any.
	TypeName *string `json:"typeName,omitempty" yaml:"typeName,omitempty" mapstructure:"typeName,omitempty"`
}

// Optional registration options if the notification supports dynamic registration.
type NotificationRegistrationOptions interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Notification) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageDirection"]; raw != nil && !ok {
		return fmt.Errorf("field messageDirection in Notification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in Notification: required")
	}
	type Plain Notification
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Notification(plain)
	return nil
}

// Represents an `or` type (e.g. `Location | LocationLink`).
type OrType struct {
	// Items corresponds to the JSON schema field "items".
	Items []OrTypeItemsElem `json:"items" yaml:"items" mapstructure:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`
}

type OrTypeItemsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in OrType: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in OrType: required")
	}
	type Plain OrType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrType(plain)
	return nil
}

// Represents an object property.
type Property struct {
	// Whether the property is deprecated or not. If deprecated the property contains
	// the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation.
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The property name;
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether the property is optional. If omitted, the property is mandatory.
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// Whether this is a proposed property. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this property is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// The type of the property
	Type PropertyType `json:"type" yaml:"type" mapstructure:"type"`
}

// The type of the property
type PropertyType interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Property) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Property: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Property: required")
	}
	type Plain Property
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Property(plain)
	return nil
}

// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
type ReferenceType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReferenceType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in ReferenceType: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ReferenceType: required")
	}
	type Plain ReferenceType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ReferenceType(plain)
	return nil
}

// Represents a LSP request
type Request struct {
	// Whether the request is deprecated or not. If deprecated the property contains
	// the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation;
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// An optional error data type.
	ErrorData RequestErrorData `json:"errorData,omitempty" yaml:"errorData,omitempty" mapstructure:"errorData,omitempty"`

	// The direction in which this request is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection" yaml:"messageDirection" mapstructure:"messageDirection"`

	// The request's method name.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// The parameter type(s) if any.
	Params interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`

	// Optional partial result type if the request supports partial result reporting.
	PartialResult RequestPartialResult `json:"partialResult,omitempty" yaml:"partialResult,omitempty" mapstructure:"partialResult,omitempty"`

	// Whether this is a proposed feature. If omitted the feature is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Optional a dynamic registration method if it different from the request's
	// method.
	RegistrationMethod *string `json:"registrationMethod,omitempty" yaml:"registrationMethod,omitempty" mapstructure:"registrationMethod,omitempty"`

	// Optional registration options if the request supports dynamic registration.
	RegistrationOptions RequestRegistrationOptions `json:"registrationOptions,omitempty" yaml:"registrationOptions,omitempty" mapstructure:"registrationOptions,omitempty"`

	// The result type.
	Result RequestResult `json:"result" yaml:"result" mapstructure:"result"`

	// Since when (release number) this request is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// The type name of the request if any.
	TypeName *string `json:"typeName,omitempty" yaml:"typeName,omitempty" mapstructure:"typeName,omitempty"`
}

// An optional error data type.
type RequestErrorData interface{}

// Optional partial result type if the request supports partial result reporting.
type RequestPartialResult interface{}

// Optional registration options if the request supports dynamic registration.
type RequestRegistrationOptions interface{}

// The result type.
type RequestResult interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Request) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageDirection"]; raw != nil && !ok {
		return fmt.Errorf("field messageDirection in Request: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in Request: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in Request: required")
	}
	type Plain Request
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Request(plain)
	return nil
}

// Represents a string literal type (e.g. `kind: 'rename'`).
type StringLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in StringLiteralType: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in StringLiteralType: required")
	}
	type Plain StringLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringLiteralType(plain)
	return nil
}

// Defines the structure of an object literal.
type Structure struct {
	// Whether the structure is deprecated or not. If deprecated the property contains
	// the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation;
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// Structures extended from. This structures form a polymorphic type hierarchy.
	Extends []StructureExtendsElem `json:"extends,omitempty" yaml:"extends,omitempty" mapstructure:"extends,omitempty"`

	// Structures to mix in. The properties of these structures are `copied` into this
	// structure. Mixins don't form a polymorphic type hierarchy in LSP.
	Mixins []StructureMixinsElem `json:"mixins,omitempty" yaml:"mixins,omitempty" mapstructure:"mixins,omitempty"`

	// The name of the structure.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The properties.
	Properties []Property `json:"properties" yaml:"properties" mapstructure:"properties"`

	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`
}

type StructureExtendsElem interface{}

// Defines an unnamed structure of an object literal.
type StructureLiteral struct {
	// Whether the literal is deprecated or not. If deprecated the property contains
	// the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation.
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The properties.
	Properties []Property `json:"properties" yaml:"properties" mapstructure:"properties"`

	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`
}

// Represents a literal structure (e.g. `property: { start: uinteger; end:
// uinteger; }`).
type StructureLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value StructureLiteral `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in StructureLiteralType: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in StructureLiteralType: required")
	}
	type Plain StructureLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StructureLiteralType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureLiteral) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in StructureLiteral: required")
	}
	type Plain StructureLiteral
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StructureLiteral(plain)
	return nil
}

type StructureMixinsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Structure) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Structure: required")
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in Structure: required")
	}
	type Plain Structure
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Structure(plain)
	return nil
}

// Represents a `tuple` type (e.g. `[integer, integer]`).
type TupleType struct {
	// Items corresponds to the JSON schema field "items".
	Items []TupleTypeItemsElem `json:"items" yaml:"items" mapstructure:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`
}

type TupleTypeItemsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TupleType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in TupleType: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in TupleType: required")
	}
	type Plain TupleType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TupleType(plain)
	return nil
}

type Type interface{}

// Defines a type alias. (e.g. `type Definition = Location | LocationLink`)
type TypeAlias struct {
	// Whether the type alias is deprecated or not. If deprecated the property
	// contains the deprecation message.
	Deprecated *string `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// An optional documentation.
	Documentation *string `json:"documentation,omitempty" yaml:"documentation,omitempty" mapstructure:"documentation,omitempty"`

	// The name of the type alias.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether this is a proposed type alias. If omitted, the type alias is final.
	Proposed *bool `json:"proposed,omitempty" yaml:"proposed,omitempty" mapstructure:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty" yaml:"since,omitempty" mapstructure:"since,omitempty"`

	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty" yaml:"sinceTags,omitempty" mapstructure:"sinceTags,omitempty"`

	// The aliased type.
	Type TypeAliasType `json:"type" yaml:"type" mapstructure:"type"`
}

// The aliased type.
type TypeAliasType interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypeAlias) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in TypeAlias: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TypeAlias: required")
	}
	type Plain TypeAlias
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypeAlias(plain)
	return nil
}

type TypeKind string

const TypeKindAnd TypeKind = "and"
const TypeKindArray TypeKind = "array"
const TypeKindBase TypeKind = "base"
const TypeKindBooleanLiteral TypeKind = "booleanLiteral"
const TypeKindIntegerLiteral TypeKind = "integerLiteral"
const TypeKindLiteral TypeKind = "literal"
const TypeKindMap TypeKind = "map"
const TypeKindOr TypeKind = "or"
const TypeKindReference TypeKind = "reference"
const TypeKindStringLiteral TypeKind = "stringLiteral"
const TypeKindTuple TypeKind = "tuple"

var enumValues_TypeKind = []interface{}{
	"base",
	"reference",
	"array",
	"map",
	"and",
	"or",
	"tuple",
	"literal",
	"stringLiteral",
	"integerLiteral",
	"booleanLiteral",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypeKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypeKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypeKind, v)
	}
	*j = TypeKind(v)
	return nil
}
